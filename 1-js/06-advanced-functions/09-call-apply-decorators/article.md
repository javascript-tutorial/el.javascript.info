# Διακοσμητές και προώθηση, call/apply

Η JavaScript δίνει εξαιρετική ευελιξία στη χρήση συναρτήσεων. Μπορούν να δοθούν σαν ορίσματα, να χρησιμοποιηθούν σαν αντικείμενα και τώρα θα δούμε πως γίνεται να *προωθήσουμε* κλήσεις μεταξύ τους και να τις *διακοσμήσουμε*.

## Διαφανές caching

Ας υποθέσουμε ότι έχουμε μια συνάρτηση `slow(x)` η οποία απαιτεί υψηλή επεξεργαστική ισχύ όμως τα αποτελέσματα της είναι σταθερά. Με άλλα λόγια, για το ίδιο `x` επιστρέφει πάντα το ίδιο αποτέλεσμα.

Αν η συνάρτηση καλείται συχνά, ενδέχεται να θέλουμε να κάνουμε cache (θυμόμαστε) τα αποτελέσματα προκείμενου να μην χρειάζεται να δαπανήσουμε επιπλέον χρόνο σε επανυπολογισμούς.

Όμως, αντί να προσθέσουμε αυτή τη λειτουργικότητα στη `slow()` θα δημιουρήσουμε μια συνάρτηση-κάλυμμα, η οποία θα προσθέσει το caching. Όπως θα δούμε, υπάρχουν αρκετά πλεονεκτήματα σε αυτή τη μέθοδο.

Αυτός είναι ο κώδικας, και οι επεξηγήσεις ακολουθούν:

```js run
function slow(x) {
  // μπορεί να είναι μια διεργασία που απαιτεί υψηλή επεξεργαστική ισχύ εδώ
  alert(`Καλέστηκε με ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {  // αν υπάρχει τέτοιο κλειδί στο cache
      return cache.get(x); // διάβασε το αποτέλεσμα από αυτό
    }

    let result = func(x);  // αλλιώς κάλεσε την func

    cache.set(x, result);  // και κανε cached (θυμήσου) το αποτέλεσμα
    return result;
  };
}

slow = cachingDecorator(slow);

<<<<<<< HEAD
alert( slow(1) ); // slow(1) είναι cached
alert( "Ξανά: " + slow(1) ); // το ίδιο

alert( slow(2) ); // slow(2) είναι cached
alert( "Ξανά: " + slow(2) ); // το ίδιο με τη προηγούμενη γραμμή
=======
alert( slow(1) ); // slow(1) is cached and the result returned
alert( "Again: " + slow(1) ); // slow(1) result returned from cache

alert( slow(2) ); // slow(2) is cached and the result returned
alert( "Again: " + slow(2) ); // slow(2) result returned from cache
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c
```

Στον από πάνω κώδικα, ο `cachingDecorator` είναι ένας *διακοσμητής*: μια ειδική συνάρτηση η οποία παίρνει μια άλλη συνάρτηση και επηρεάζει την συμπεριφορά της.

Η ιδέα είναι ότι μπορούμε να καλέσουμε τον `cachingDecorator` για κάθε συνάρτηση, και αυτός θα επιστρέψει τη συνάρτηση-κάλυμμα του cache. Αυτό είναι πολύ καλό, γιατί μπορούμε να έχουμε πολλές συναρτήσεις που μπορούν να χρησιμοποιήσουν αυτό το χαρακτηριστικό, και το μόνο που χρειάζεται να κάνουμε είναι να εφαρμόσουμε τον `cachingDecorator` σε αυτές.

Με το να διαχωρίζουμε το caching από τη συνάρτηση με τον βασικό κώδικα, διατηρούμε και τον βασικό κώδικα πιο απλό.

Το αποτέλεσμα της `cachingDecorator(func)` είναι μια συνάρτηση-κάλυμμα: `function(x)` που "καλύπτει" το κάλεσμα της `func(x)` με λογική caching:

![](decorator-makecaching-wrapper.svg)

Από κάποιον εξωτερικό κώδικα, η συνάρτηση που επικαλύπτεται `slow` συνεχίζει να κάνει το ίδιο. Απλά προστέθηκε ένας caching παράγοντας στη συμπεριφορά της.

Για να συνοψίσουμε, υπάρχουν αρκετά πλεονεκτήματα της χρήσης ενός ξεχωριστού `cachingDecorator` αντί να αλλάξει ο κώδικας της ίδιας της `slow`.

- Ο `cachingDecorator` είναι επαναχρησιμοποιήσιμος. Μπορούμε να την εφαρμόσουμε σε άλλη συνάρτηση.
- Η λογική cache είναι διαχωρισμένη, δεν αύξησε τη πολυπλοκότητα της ίδιας της `slow` (εαν υπήρχε κάποια).
- Μπορούμε να συνδυάσουμε πολλαπλούς διακοσμητές αν χρειάζεται (οι άλλοι διακοσμητές θα ακολουθήσουν).

## Χρησιμοποιώντας "func.call" για το πλαίσιο.

O διακοσμητής caching που αναφέρθυηκε πάνω δεν είναι κατάλληλος για χρήση με μεθόδους αντικειμένου.

Για παράδειγμα, στον κώδικα κάτω η `worker.slow()` σταματάει να τρέχει μετά την διακόσμηση.

```js run
// θα παράξουμε caching με τη worker.slow
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // "βαριά" υπολογιστική διαδικασία εδώ
    alert("Καλέστηκε με " + x);
    return x * this.someMethod(); // (*)
  }
};

// ο ίδιος κώδικας με πριν
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
*!*
    let result = func(x); // (**)
*/!*
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); // η αρχική μέθοδος δουλεύει

worker.slow = cachingDecorator(worker.slow); // χρησιμοποίησε το caching

*!*
alert( worker.slow(2) ); // Whoops! Error: Cannot read property 'someMethod' of undefined
*/!*
```

Το error προκύπτει στην γραμμή `(*)` που προσπαθεί να έχει πρόσβαση στη `this.someMethod` και αποτυγχάνει. Μπορείς να δεις γιατί?

Ο λόγος είναι ότι η συνάρτηση-κάλυμμα καλεί την αρχική συνάρτηση σαν `func(x)` στη γραμμή `(**)`. Και, όταν καλείται με αυτό το τρόπο, η συνάρτηση παίρνει `this = undefined`.

Θα παρατηρούσαμε ένα παρόμοιο αποτέλεσμα αν προσπαθούσαμε να τρέξουμε:

```js
let func = worker.slow;
func(2);
```

Οπότε, η συνάρτηση-κάλυμμα δίνει τη κλήση στην αρχική μέθοδο, αλλά χωρίς το πλαίσιο `this`. Έτσι δημιουργείτε το error.

Ας το διορθώσουμε.

Υπάρχει μια ειδική ενσωματωμένη συνάρτηση-μέθοδος [func.call(context, ...args)](mdn:js/Function/call) η οποία επιτρέπει τη κλήση μιας συνάρτησης ρητά θέτωντας το `this`.

Η σύνταξη είναι:

```js
func.call(context, arg1, arg2, ...)
```

Τρέχει το `func` δίνοντας το πρώτο όρισμα σαν `this`, και το επόμενο σαν τα ορίσματα.

Για να το πούμε απλά, αυτές οι δύο κλήσεις κάνουν σχεδόν το ίδιο.

```js
func(1, 2, 3);
func.call(obj, 1, 2, 3)
```

Καλούν και οι δύο τη `func` με ορίσματα τα `1`, `2` and `3`. Η μόνη διαφορά είναι ότι η `func.call` επίσης θέτει το `this` στο `obj`.

Σαν παράδειγμα, στον κώδικα από κάτω, καλούμε τη `sayHi` στο πλαίσιο διαφορετικών αντικειμένων: η `sayHi.call(user)` τρέχει τη `sayHi` δίνοντας `this=user`, και η επόμενη γραμμή θέτει `this=admin`:

```js run
function sayHi() {
  alert(this.name);
}

let user = { name: "Γιάννης" };
let admin = { name: "Διαχειριστής" };

// χρησιμοποιήσε τη κλήση για το θέσιμο διαφορετικών αντικειμένων σαν "this"
sayHi.call( user ); // this = Γιάννης
sayHi.call( admin ); // this = Διαχειριστής
```

Και εδώ χρησιμοποιούμε `call` για να καλέσουμε τη `say` με το δοσμένο context και τη φράση:

```js run
function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: "Γιάννης" };

// ο χρήστης γίνεται this, και το "Γεια σου" γίνεται το πρώτο όρισμα
say.call( user, "Γεια" ); // Γιάννης: Γεια
```

Στη περίπτωση μας, μπορούμε να χρησιμοποιήσουμε τη `call` στη συνάρτηση-κάλυμμα για να δώσουμε το context στην αρχική συνάρτηση:

```js run
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Καλέστηκε με " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
*!*
    let result = func.call(this, x); // "this" δίνεται σωστά τώρα
*/!*
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // τώρα να κάνει caching

alert( worker.slow(2) ); // δουλεύει
alert( worker.slow(2) ); // δουλεύει, δεν καλεί το αρχικό (cached)
```

Τώρα όλα λειτουργούν σωστά.

Για να γίνουν όλα πιο ξεκάθαρα, ας δούμε πιο βαθιά πώς το `this` περνάει μέσα από τις κλήσεις:

1. Μετά τη διακόσμηση η `worker.slow` είναι τώρα η συνάρτηση-κάλυμμα `function (x) { ... }`.
2. Οπότε όταν η `worker.slow(2)` εκτελείται, η συνάρτηση-κάλυμμα παίρνει `2` σαν ένα όρισμα και το `this=worker` (είναι το αντικέιμενο πρίν τη τελεία).
3. Μέσα στη συνάρτηση-κάλυμμα, υποθέτωντας ότι το αποτέλεσμα δεν έχει γίνει ακόμα cached, η `func.call(this, x)` δίνει το τωρινό `this` (`=worker`) και το τωρινό όρισμα (`=2`) στην αρχική μέθοδο.


## Πολλαπλά ορίσματα με τη "func.apply"


Τώρα ας κάνουμε τον `cachingDecorator` ακόμα πιο γενικό. Μέχρι τώρα δούλευε μόνο με συναρτήσεις με ένα όρισμα.

Πώς γίνεται να κάνουμε cache τη μέθοδο `worker.slow` που έχει πολλαπλά ορίσματα?

```js
let worker = {
  slow(min, max) {
    return min + max; // εργασία που απαιτεί υψηλή επεξεργαστική ισχύ εδώ
  }
};

// πρέπει να θυμάται τις κλήσεις με τα ίδια ορίσματα
worker.slow = cachingDecorator(worker.slow);
```

Προηγουμένως, για ένα μονό όρισμα `x` θα μπορούσαμε να χρησιμοποιήσουμε τη `cache.set(x, result)` για να σώσουμε το αποτέλεσμα και μετά με την `cache.get(x)` να το ανακτήσουμε. Τώρα όμως πρέπει να θυμόμαστε το αποτέλεσμα για ένα *συνδυασμό από ορίσματα* `(min,max)`. Το υπάρχον `Map` παίρνει μια τιμή μόνο σαν κλειδί.  

Υπάρχουν αρκετές δυνατές λύσεις:

1. Η δημιουργία μιας νέας (η χρήση μιας τρίτης) δομής δεδομένων που να μοιάζει με map η οποία θα έιναι πιο εύελικτη και θα επιτρέπει πολλαπλά κλειδιά.
2. Η χρήση εμφωλευμένων maps: `cache.set(min)` θα είναι ένα `Map` που θα αποθηκέυει το ζευγάρι `(max, result)`. Έτσι μπορούμε να πάρουμε το `result` σαν `cache.get(min).get(max)`.
3. Η ένωση δύο τιμών σε μία. Στη συγκεκρίμενη περίπτωση μπορούμε να χρησιμοποιήσουμε ένα string `"min,max"` σαν το κλειδί για το `Map`. Για ευελιξία, μπορούμε να δώσουμε μια *συνάρτηση κατακερματισμού* για τον διακοσμητή, η οποία θα γνωρίζει πώς να δημιουργεί μια τιμή από πολλές.

Για αρκετές πρακτικές εφαρμογές, η 3η επιλογή είναι αρκετά καλή, οπότε θα μείνουμε με αυτή.

Επίσης, χρειάζεται να αντικαταστήσουμε τη `func.call(this, x)` με τη `func.call(this, ...arguments)`, για να δώσουμε όλα τα ορίσματα στο κάλεσμα της συνάρτησης-κάλυμμα, όχι μόνο το πρώτο.


Ας δούμε ένα πιο ισχυρό `cachingDecorator`:

```js run
let worker = {
  slow(min, max) {
    alert(`Καλέστηκε με ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
*!*
    let key = hash(arguments); // (*)
*/!*
    if (cache.has(key)) {
      return cache.get(key);
    }

*!*
    let result = func.call(this, ...arguments); // (**)
*/!*

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // δουλεύει
alert( "Ξανά " + worker.slow(3, 5) ); // το ίδιο (cached)
```

Τώρα δουλεύει με οποιοδήποτε αριθμό ορισμάτων (ωστόσο η συνάρτηση κατακερματισμού θα πρέπει να προσαρμοστεί για να επιτρέπει οποιοδήποτε αριθμό ορισμάτων. Ένας ενδιαφέρον τρόπος για χειριστούμε αυτό θα καλυφθεί πιο κάτω).

Υπάρχουν δύο αλλαγές:

- Στη γραμμή `(*)` καλείται η `hash` για να δημιουργήσει ένα μόνο κλειδί από τα `arguments`. Εδώ χρησιμοποιούμε μια απλή συνάρτηση "ένωσης" η οποία μετατρέπει τα ορίσματα `(3, 5)` στο κλειδί `"3,5"`. Πιο πολύπλοκες περιπτώσεις μπορεί να χρειάζονται άλλες συναρτήσεις κατακερματισμού.
- Έπειτα στο `(**)` χρησιμοποιείται η `func.call(this, ...arguments)` για να δωθούν τόσο το context όσο και όλα τα ορίσματα που απέκτησε ο wrapper (όχι μόνο το πρώτο) στην αρχική συνάρτηση.

Αντί για `func.call(this, ...arguments)` υα μπορούσαμε να χρησιμοποιήσουμε τη `func.apply(this, arguments)`.

Η σύνταξη της ενσωματωμένης συνάρτησης [func.apply](mdn:js/Function/apply) είναι:

```js
func.apply(context, args)
```

Τρέχει τη `func` θέτωντας `this=context` και χρησιμοποιώντας ένα αντικέιμενο που μοιάζει με πίνακα και ονομάζεται `args` σαν τη λίστα των ορισμάτων.

Η μόνη συντακτική διαφορά ανάμεσα στο `call` και το `apply` είναι ότι το `call` περιμένει μια λίστα από ορίσματα, ενώ το `apply` δέχεται ένα αντικέιμενο που έχει τη μορφή πίνακα με αυτά.

Οπότε οι δύο αυτές κλήσεις είναι σχεδόν ίδιες:

```js
<<<<<<< HEAD
func.call(context, ...args); // δώσε ένα πίνακα σαν λίστα με τον τελεστή διασποράς
func.apply(context, args);   // είναι το ίδιο χρησιμοποιώντας apply
```

=======
func.call(context, ...args);
func.apply(context, args);
```

They perform the same call of `func` with given context and arguments.

There's only a subtle difference regarding `args`:
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Υπάρχει μόνο μία μικρή διαφορά:

<<<<<<< HEAD
- Ο τελεστής διασποράς `...` επιτρέπει το δώσιμο του *iterable* `args` σαν τη λίστα στο `call`.
- Η `apply` δέχεται μόνο *σαν-πίνακα* `args`.

Άρα, αυτές οι δύο κλήσεις συμπληρώνουν η μία την άλλη. Όπου περιμένουν ένα iterable, η `call` λειτουργεί, όπου περιμένουμε κάτι σαν πίνακα, η `apply` λειτουργεί εκεί.
=======
...And for objects that are both iterable and array-like, such as a real array, we can use any of them, but `apply` will probably be faster, because most JavaScript engines internally optimize it better.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Και για αντικέιμενα που είναι και iterable και σαν πίνακες, όπως ένας πραγματικός πίνακας, τεχνικά θα μπορούσαμε να χρησιμοποιήσουμε οποιαδήποτε από αυτές, όμως η `apply` θα είναι πιθανότατα πιο γρήγορη, διότι οι περισσότερες μηχανές JavaScript εσωτερικά τη βελτιστοποιούν καλύτερα.

Δίνοντας όλα τα ορίσματα μαζί με το context σε μια άλλη συνάρτηση λέγεται *προώθηση κλήσης*

Η πιο απλή του μορφή είναι αυτή:

```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```

Όταν ένας εξωτερικός κώδικας καλεί μια τέτοια `wrapper`, είναι δυσδιάκριτο από τη κλήση της αρχικής συνάρτησης `func`.

## Δανεισμός μιας μεθόδου [#δανεισμός-μεδόδου]

Τώρα ας κάνουμε μια μικρή βελτιστοποίηση στη συνάρτηση κατακερματισμού:

```js
function hash(args) {
  return args[0] + ',' + args[1];
}
```

Μέχρι τώρα, δουλεύει μόνο σε δύο ορίσματα. Θα ήταν καλύτερο αν μπορούσε να ενώσει οποιοδήποτε αριθμό από `args`.

Η φυσική λύση θα ήταν η χρήση της μεθόδου [arr.join](mdn:js/Array/join):

```js
function hash(args) {
  return args.join();
}
```

...Δυστυχώς, αυτό δεν θα δουλέψει. Επειδή καλούμε τη `hash(arguments)` και το αντικέιμενο `arguments` είναι και iterable και σαν-πίνακας, αλλά όχι ένας πραγματικός πίνακας.

Έτσι το να καλέσουμε τη `join` θα αποτύγχανε, όπως βλέπουμε παρακάτω:

```js run
function hash() {
*!*
  alert( arguments.join() ); // Error: arguments.join is not a function
*/!*
}

hash(1, 2);
```

Ωστόσο, υπάρχει ένα εύκολος τρόπος να χρησιμοποιήσουμε την ένωση πινάκων:

```js run
function hash() {
*!*
  alert( [].join.call(arguments) ); // 1,2
*/!*
}

hash(1, 2);
```

Ο τρόπος ονομάζεται *δανεισμός μεθόδου*.

Παίρνουμε (δανειζόμαστε) μια μέθοδο ένωσης από ένα κανονικό πίνακα (`[].join`) και χρησιμοποιούμε `[].join.call` για να το τρέξουμε στο context των `arguments`.

Γιατί δουλεύει?

Αυτό είναι γιατί ο εσωτερικός αλγόριθμος της υπάρχουσας μεθόδου `arr.join(glue)` είναι πολύ απλός.

Από το specification της γλώσσας ισχύει:

1. Έστω ότι το `glue` είναι το πρώτο όρισμα ή, αν δεν υπάρχουν ορίσματα, τότε μια κόμμα `","`.
2. Έστω ότι το `result` είναι μια άδεια συμβολοσειρά.
3. Προσάρτησε το `this[0]` στο `result`.
4. Προσάρτησε το `glue` στο `this[1]`.
5. Προσάρτησε το `glue` στο `this[2]`.
6. ...Συνέχισε έτσι μέχρι `this.length` από πράγματα έχουν ενωθεί.
7. Επέστρεψε το `result`.

Οπότε, τεχνικά, παίρνει το `this` και ενώνει `this[0]`, `this[1]` ...κτλπ μαζί. Είναι επίτηδες γραμμένο με αυτό το τρόπο που να επιτρέπει οποιοδήποτε `this` με τη μορφή πίνακα (δεν είναι σύμπτωση, πολλές μέθοδοι ακολουθούν αυτή τη πρακτική). Για το λόγο αυτό δουλεύει και με το `this=arguments`.

## Διακοσμητές και ιδιότητες συναρτήσεων

Είναι γενικά ασφαλής η αντικατάσταση μιας συνάρτησης η μιας μεθόδου με μια διακοσμημένη, εκτός από μια μικρή περίπτωση. Αν η αρχική συνάρτηση έχει ιδιότητες μέσα της, όπως η `func.calledCount` η οποιαδήποτε άλλη, τότε η διακοσμημένη συνάρτηση δεν θα της διαθέσει. Διότι αυτή είναι μια συνάρτηση-κάλυμμα. Οπότε θέλουν ιδιαίτερη προσόχη στη χρήση τους.

Π.χ. στο παράδειγμα πάνω αν η συνάρτηση `slow` είχε ιδιότητες μέσα της, τότε ο `cachingDecorator(slow)` είναι μια συνάρτηση-κάλυμμα χωρίς αυτές.

Κάποιοι διακοσμητές ενδέχεται να προσφέρουν τις δικές τους ιδιότητες. Π.χ. ένας διακοσμητής μπορεί να μετράει πόσες φορές μια συνάρτηση έτρεξε και πόσο χρόνο πήρε, και να προωθεί τη πληροφορία αυτή μέσω ιδιοτήτων της συνάρτησης-κάλυμμα.

Υπάρχει ένας τρόπος για να δημιουργηθούν διακοσμητές που κρατάνε πρόσβαση στις ιδιότητες της συνάρτησης, αλλά αυτό απαιτεί τη χρήση ενός ειδικού `Proxy` αντικέιμενου για να περικλύσει την συνάρτηση. Θα το συζητήσουμε αυτό αργότερα στο άρθρο <info:proxy#proxy-apply>.

## Σύνοψη

*Διακοσμητής* είναι ένα κάλυμμα γύρω από μια συνάρτηση το οποία αλλάζει τη συμπεριφορά της. Η κύρια δουλειά συνεχίζει να γίνεται από την συνάρτηση.

Οι διακοσμητές μπορούν να θεωρηθούν σαν "χαρακτηριστικά" ή "γνωρίσματα" που μπορούν να προστεθούν σε μια συνάρτηση. Μπορούμε να προσθέσουμε ένα ή πολλά. Και όλα αυτά χωρίς να αλλάζουμε τον κώδικα της.

Για να υλοποιήσουμε τον `cachingDecorator`, είδαμε τις μεθόδους:

- [func.call(context, arg1, arg2...)](mdn:js/Function/call) -- καλεί τη `func` με το δοσμένο context και ορίσματα.
- [func.apply(context, args)](mdn:js/Function/apply) -- καλεί τη `func` δίνοντας το `context` σαν το `this` και στη μορφή πίνακα `args` σε μια λίστα από ορίσματα.

Η γενικότερη μορφή *προώθησης κλήσης* συνήθως γίνεται με την `apply`:


```js
let wrapper = function() {
  return original.apply(this, arguments);
};
```

Επίσης είδαμε ένα παράδειγμα από *δανεισμό μεθόδου* όπου παίρνουμε μια μέθοδο από ένα αντικείμενο και κάνουμε `call` σε αυτό στο πλαίσιο ενός άλλου αντικειμένου. Είναι αρκετά συνηθισμένο να παίρνουμε μεθόδους πινάκων και να τις εφαρμόζουμε στα `arguments`. Η εναλλακτική λύση είναι να χρησιμοποιήσουμε τις παραμέτρους υπολοίπου ενός αντικειμένου που είναι ένας πραγματικός πίνακας.

Υπάρχουν αρκετοί διακοσμητές εκεί έξω. Έλεγξε πόσο καλά τους κατάλαβες λύνοντας τις ασκήσεις αυτού του κεφαλαίου.
