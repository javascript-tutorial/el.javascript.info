# Βρόχοι: while καί for

Συχνά πρέπει να επαναλάβουμε τις ενέργειες.

Για παράδειγμα, η παραγωγή προϊόντων από τη λίστα μία μετά την άλλη ή απλώς με τον ίδιο κώδικα για κάθε αριθμό από 1 έως 10.

Οι *βρόχοι* είναι ένας τρόπος επανάληψης του ίδιου κώδικα πολλές φορές.

## Ο βρόχος "while"

Ο βρόχος `while` έχει την ακόλουθη σύνταξη:

```js
while (condition) {
  // κώδικας
  // επονομαζόμενος "loop body"
}
```

Ενώ η `condition` είναι αληθινή, εκτελείται ο `code` από το σώμα του βρόχου.

Για παράδειγμα, ο παρακάτω βρόχος θα δείξει `i` while `i < 3`:

```js run
let i = 0;
while (i < 3) { // δείξε 0, μετά 1, μετά 2
  alert( i );
  i++;
}
```

Μια μεμονωμένη εκτέλεση του σώματος βρόχου ονομάζεται *επανάληψη*. Ο βρόχος στο παραπάνω παράδειγμα κάνει τρεις επαναλήψεις.

Εάν το `i++` έλειπε από το παραπάνω παράδειγμα, ο βρόχος θα επαναλαμβανόταν (θεωρητικά) για πάντα. Στην πράξη, το πρόγραμμα περιήγησης παρέχει τρόπους για να σταματήσετε αυτούς τους βρόχους και σε JavaScript από την πλευρά του διακομιστή, μπορούμε να σταματήσουμε τη διαδικασία.

Οποιαδήποτε έκφραση ή μεταβλητή μπορεί να είναι μια κατάσταση βρόχου, όχι μόνο συγκρίσεις: η συνθήκη αξιολογείται και μετατρέπεται σε δυαδική από το `while`

Για παράδειγμα, ένας συντομότερος τρόπος για να γράψετε το `while (i != 0)` είναι `while (i)`:

```js run
let i = 3;
*!*
while (i) { // όταν το `i` γίνει 0, η κατάσταση γίνεται falsy και ο βρόχος σταματά
*/!*
  alert( i );
  i--;
}
```

````smart header="Curly braces are not required for a single-line body"
Εάν το σώμα του βρόχου έχει μία μόνο δήλωση, μπορούμε να παραλείψουμε τα άγκυστρα `{…}`:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## Οι βρόχοι "do..while" 

Ο έλεγχος συνθηκών μπορεί να μετακινηθεί *κάτω* από το σώμα του βρόχου χρησιμοποιώντας τη σύνταξη `do..while`:

```js
do {
  // loop body
} while (condition);
```

Ο βρόχος θα εκτελέσει πρώτα το σώμα, μετά θα ελέγξει την κατάσταση και, όσο είναι truthy, θα το εκτελεί ξανά και ξανά.

Για παράδειγμα:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```
Αυτή η μορφή σύνταξης πρέπει να χρησιμοποιείται μόνο όταν θέλετε το σώμα του βρόχου να εκτελεί **τουλάχιστον μία φορά** ανεξάρτητα από την truthy της κατάστασης. Συνήθως, προτιμάται η άλλη μορφή:
`while(…) {…}`.

## Ο βρόχος "for"

Ο βρόχος `for` είναι πιο περίπλοκος, αλλά είναι επίσης ο βρόχος που χρησιμοποιείται πιο συχνά.

Μοιάζει κάπως έτσι:

```js
for (begin; condition; step) {
  // ... loop body ...
}
```
Ας μάθουμε για παράδειγμα την έννοια αυτών των μερών. Ο βρόχος παρακάτω τρέχει `alert(i)` for i` από `0` έως (αλλά δεν περιλαμβάνει) `3`:

```js run
for (let i = 0; i < 3; i++) { // δείξε 0, μετά 1, μετά 2
  alert(i);
}
```
Ας εξετάσουμε την συνθήκη `for` βήμα - βήμα:

| part  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| begin | `i = 0`    | Εκτελείται μία φορά κατά την είσοδο του βρόχου.                                      |
| condition | `i < 3`| Ελέγχεται πριν από κάθε επανάληψη βρόχου. Εάν είναι λάθος, ο βρόχος σταματά.             |
| body | `alert(i)`| Τρέχει ξανά και ξανά οσο η κατάσταση είναι αληθινή           |
| step| `i++`      | Εκτελείται μετά το σώμα σε κάθε επανάληψη. |

Ο γενικός αλγόριθμος βρόχου λειτουργεί κάπως έτσι:

```
Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
```

Δηλαδή, το `begin` εκτελείται μία φορά και στη συνέχεια επαναλαμβάνεται: μετά από κάθε δοκιμή του `condition`, εκτελούνται `body` και `step`.

Εάν είστε νέοι στους βρόχους, θα μπορούσε να σας βοηθήσει να επιστρέψετε στο παράδειγμα και να αναπαραγάγετε τον τρόπο λειτουργίας του βήμα προς βήμα σε ένα κομμάτι χαρτί.

Στην δική μας περίπτωσή συμβαίνει ακριβώς αυτό:

```js
// for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...τέλος, επειδη το i == 3
```

````smart header="Inline variable declaration"
Εδώ, η μεταβλητή "counter" δηλώνεται ακριβώς στο βρόχο. Αυτό ονομάζεται "inline" μεταβλητή δήλωση. Τέτοιες μεταβλητές είναι ορατές μόνο εντός του βρόχου

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // σφάλμα, δεν υπάρχει τέτοια μεταβλητή
```
Αντί να ορίσουμε μια μεταβλητή, θα μπορούσαμε να χρησιμοποιήσουμε μια υπάρχουσα:

```js run
let i = 0;

for (i = 0; i < 3; i++) { //  χρησιμοποιούμε μια υπάρχουσα
  alert(i); // 0, 1, 2
}

alert(i); // 3, ορατό, επειδή δηλώνεται εκτός του βρόχου
```

````


### Παράλειψη τμήματος

Μπορείτε να παραλείψετε οποιοδήποτε μέρος του `for`.

Για παράδειγμα, μπορούμε να παραλείψουμε το `begin` εάν δεν χρειάζεται να κάνουμε τίποτα κατά την έναρξη του βρόχου.

Οπως εδώ:

```js run
let i = 0; // έχουμε ήδη δηλώσει και αναθέσει το i

for (; i < 3; i++) { // δεν χρειάζεται στο "begin"
  alert( i ); // 0, 1, 2
}
```

Μπορούμε επίσης να αφαιρέσουμε το τμήμα `step`:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

Αυτό κάνει το βρόχο πανομοιότυπο με `while (i < 3)`.

Μπορούμε πραγματικά να αφαιρέσουμε τα πάντα, δημιουργώντας έναν άπειρο βρόχο:

```js
for (;;) {
  // επαναλαμβάνεται χωρίς όρια
}
```

Σημειώστε ότι πρέπει να υπάρχουν τα δύο `;` ερωτηματικά για το `for`. Διαφορετικά, θα υπάρχει σφάλμα σύνταξης.

## Διακοπή του βρόχου

Κανονικά, ένας βρόχος βγαίνει όταν η κατάστασή του γίνει falsy.

Αλλά μπορούμε να αναγκάσουμε την έξοδο ανά πάσα στιγμή χρησιμοποιώντας την ειδική οδηγία `break`.

Για παράδειγμα, ο παρακάτω βρόχος ζητά από το χρήστη μια σειρά αριθμών, "breaking" όταν δεν έχει εισαχθεί αριθμός:

```js run
let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Sum: ' + sum );
```
Η οδηγία `break` ενεργοποιείται στη γραμμή `(*)` εάν ο χρήστης εισάγει μια κενή γραμμή ή ακυρώσει την είσοδο. Σταματά το βρόχο αμέσως, περνώντας τον έλεγχο στην πρώτη γραμμή μετά το βρόχο. Δηλαδή, `alert`.

Ο συνδυασμός "infinite loop + `break` όπως απαιτείται" είναι ιδανικός για καταστάσεις όπου η κατάσταση ενός βρόχου πρέπει να ελεγχθεί όχι στην αρχή ή στο τέλος του βρόχου, αλλά στη μέση ή ακόμη και σε πολλά σημεία του body.

## Συνεχίστε στην επόμενη επανάληψη [#continue]

Η οδηγία `continue` είναι μια "ελαφρύτερη έκδοση" του `break`. Δεν σταματά ολόκληρο τον βρόχο. Αντ 'αυτού, σταματά την τρέχουσα επανάληψη και αναγκάζει τον βρόχο να ξεκινήσει μια νέα (εάν το επιτρέπει η συνθήκη).

Μπορούμε να το χρησιμοποιήσουμε αν τελειώσουμε με την τρέχουσα επανάληψη και θέλουμε να προχωρήσουμε στην επόμενη.

Ο βρόχος χρησιμοποιεί το παρακάτω `continue` για την έξοδο μόνο περιττών τιμών:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // εάν είναι αλήθεια, παράλειψε το υπόλοιπο μέρος του σώματος
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, then 3, 5, 7, 9
}
```
Για ζυγές τιμές του `i`, η οδηγία `continue` σταματά να εκτελεί το σώμα και περνά τον έλεγχο στην επόμενη επανάληψη του `for` (με τον επόμενο αριθμό). Επομένως, το `alert` καλείται μόνο για περιττές τιμές.

````smart header="Η οδηγία `continue` συμβάλλει στη μείωση του nesting"
Ένας βρόχος που δείχνει περιττές τιμές θα μπορούσε να μοιάζει με αυτό:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

Από τεχνική άποψη, αυτό είναι πανομοιότυπο με το παραπάνω παράδειγμα. Σίγουρα, μπορούμε απλώς να τυλίξουμε τον κώδικα σε ένα μπλοκ `if` αντί να χρησιμοποιήσουμε το `continue`.

Αλλά ως παρενέργεια, αυτό δημιούργησε ένα ακόμη επίπεδο ένθεσης (η κλήση `alert` μέσα στα άγκυστρα). Εάν ο κώδικας στο εσωτερικό του `if` είναι μεγαλύτερος από μερικές γραμμές, αυτό μπορεί να μειώσει τη συνολική αναγνωσιμότητα.
````

````warn header="Δεν υπάρχει `break/continue` στη δεξιά πλευρά του '?'"
Λάβετε υπόψη ότι οι δομές σύνταξης που δεν είναι εκφράσεις δεν μπορούν να χρησιμοποιηθούν με τον ternary τελεστή `?`. Συγκεκριμένα, δεν επιτρέπονται οδηγίες όπως `break/continue`.

Για παράδειγμα, αν λάβουμε αυτόν τον κωδικό:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...και να το ξαναγράψουμε χρησιμοποιώντας ένα ερωτηματικό:


```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // το continue δεν επιτρέπεται εδώ
```

...σταματά να λειτουργεί: υπάρχει σφάλμα σύνταξης.

Αυτός είναι ένας άλλος λόγος για να μην χρησιμοποιήσετε τον τελεστή ερωτηματικών `;` αντί για `if`.
````

## Ετικέτα για break/continue

Μερικές φορές πρέπει να διακόπψουμε από πολλούς ένθετους βρόχους ταυτόχρονα.

Για παράδειγμα, στον παρακάτω κώδικα με βροχο στο `i` και `j`, ζητάμε τις συντεταγμένες `(i, j)` απο `(0,0)` προς `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // τι γίνεται εάν θέλουμε να βγούμε από εδώ στο Done (παρακάτω);
  }
}

alert('Done!');
```

Χρειαζόμαστε έναν τρόπο να σταματήσουμε τη διαδικασία εάν ο χρήστης ακυρώσει την εισαγωγή.

The ordinary `break` after `input` would only break the inner loop. That's not sufficient--labels, come to the rescue!

Το συνήθης `break` μετά την `input` θα σπάσει μόνο τον εσωτερικό βρόχο. Αυτό δεν είναι αρκετή--ετικέτα, για να διασωθή!

Η *ετικέτα* είναι ένα αναγνωριστικό με άνω και κάτω τελεία πριν από έναν βρόχο:
```js
labelName: for (...) {
  ...
}
```

Η δήλωση `break <labelName>` στον παρακάτω βρόχο διακόπτη την ετικέτα:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // εάν είναι μια κενή συμβολοσειρά ή canceled, τότε διέκοψε και από τους δύο βρόχους
    if (!input) *!*break outer*/!*; // (*)

    // κανε κατι με την τιμή...
  }
}
alert('Done!');
```

Στον παραπάνω κώδικα, το `break outer` αναζητά προς τα πάνω την ετικέτα με το όνομα `outer` και διάκοπτεται από αυτόν τον.

Έτσι ο έλεγχος πηγαίνει κατευθείαν από `(*)` προς `alert('Done!')`.

Μπορούμε επίσης να μετακινήσουμε την ετικέτα σε ξεχωριστή γραμμή:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```
Η οδηγία `continue` μπορεί επίσης να χρησιμοποιηθεί με μια ετικέτα. Σε αυτήν την περίπτωση, η εκτέλεση κώδικα μεταβαίνει στην επόμενη επανάληψη του επισημασμένου βρόχου.

````warn header="Labels do not allow to \"jump\" anywhere"
Οι ετικέτες δεν μας επιτρέπουν να μεταβούμε σε αυθαίρετο μέρος στον κώδικα.

Για παράδειγμα, αυτό είναι αδύνατο να γίνει:
```js
break label; // δεν μεταβαίνει στην παρακάτω ετικέτα

label: for (...)
```
Μια κλήση για `break/continue` είναι δυνατή μόνο μέσα από ένα βρόχο και η ετικέτα πρέπει να βρίσκεται κάπου πάνω από την οδηγία.
````

## Περίληψη

Καλύψαμε 3 τύπους βρόχων:

- `while` -- Η συνθήκη ελέγχεται πριν από κάθε επανάληψη.
- `do..while` -- Η συνθήκη ελέγχεται μετά από κάθε επανάληψη.
- `for (;;)` -- Η κατάσταση ελέγχεται πριν από κάθε επανάληψη, διαθέσιμες πρόσθετες ρυθμίσεις.

Για να δημιουργήσετε έναν "άπειρο" βρόχο, συνήθως χρησιμοποιείται η κατασκευή `while(true)`. Ένας τέτοιος βρόχος, όπως και κάθε άλλος, μπορεί να σταματήσει με την οδηγία `break`.

Εάν δεν θέλουμε να κάνουμε τίποτα στην τρέχουσα επανάληψη και θέλουμε να προωθήσουμε στην επόμενη, μπορούμε να χρησιμοποιήσουμε την οδηγία `continue`.

Tα `break/continue` υποστήριζουνται πριν από το βρόχο. Μια ετικέτα είναι ο μόνος τρόπος για να `break/continue` να ξεφύγει από έναν ένθετο βρόχο για να πάει σε έναν εξωτερικό.






