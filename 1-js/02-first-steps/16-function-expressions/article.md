# Εκφράσεις συναρτήσεων

Στην JavaScript, μια συνάρτηση δεν είναι μια "μαγική δομή γλώσσας", αλλά ένα ειδικό είδος αξίας.

Η σύνταξη που χρησιμοποιούμε ονομάζεται _Function Declaration_:

```js
function sayHi() {
  alert("Hello");
}
```

Υπάρχει μια άλλη σύνταξη για τη δημιουργία μιας συνάρτησης που ονομάζεται _Function Expression_.

Μας επιτρέπει να δημιουργήσουμε μια νέα συνάρτηση στη μέση οποιασδήποτε έκφρασης.

Για παράδειγμα:

```js
let sayHi = function () {
  alert("Hello");
};
```

Εδώ μπορούμε να δούμε μια μεταβλητή `sayHi` να παίρνει μια τιμή, τη νέα συνάρτηση, που δημιουργήθηκε ως `function() { alert("Hello"); }`.

Καθώς η δημιουργία της συνάρτησης συμβαίνει στο πλαίσιο της έκφρασης ανάθεσης (στη δεξιά πλευρά του `=`), αυτή είναι μια έκφραση ενός _Function_.

Λάβετε υπόψη ότι δεν υπάρχει όνομα μετά τη λέξη-κλειδί `funtion`. Η παράλειψη ενός ονόματος επιτρέπεται για τις εκφράσεις συναρτήσεων.

Εδώ το εκχωρούμε αμέσως στη μεταβλητή, οπότε η σημασία αυτών των δειγμάτων κώδικα είναι η ίδια: "δημιουργήστε μια συνάρτηση και βάλτε τη στη μεταβλητή `sayHi`.

Σε πιο προχωρημένες καταστάσεις, που θα συναντήσουμε αργότερα, μια συνάρτηση μπορεί να δημιουργηθεί και να κληθεί αμέσως ή να προγραμματιστεί για μεταγενέστερη εκτέλεση, να μην αποθηκευτεί πουθενά, με αποτέλεσμα να παραμείνει ανώνυμη.

## Η συνάρτηση είναι μια τιμή

Ας επαναλάβουμε: ανεξάρτητα από το πώς δημιουργείται η συνάρτηση, μια συνάρτηση είναι μια τιμή. Και τα δύο παραπάνω παραδείγματα αποθηκεύουν μια συνάρτηση στη μεταβλητή`sayHi`.

Μπορούμε ακόμη και να εμφανίσουμε αυτήν την τιμή χρησιμοποιώντας την εντολή `alert`:

```js run
function sayHi() {
  alert( "Hello" );
}

*!*
alert( sayHi ); // δείχνει τον κωδικό της συνάρτησης
*/!*
```

Λάβετε υπόψη ότι η τελευταία γραμμή δεν εκτελεί τη συνάρτηση, επειδή δεν υπάρχουν παρενθέσεις μετά το `sayHi`. Υπάρχουν γλώσσες προγραμματισμού όπου οποιαδήποτε αναφορά ονόματος συνάρτησης προκαλεί την εκτέλεσή της, αλλά η JavaScript δεν είναι έτσι.

Στο JavaScript, μια συνάρτηση είναι μια τιμή, επομένως μπορούμε να την αντιμετωπίσουμε ως τιμή. Ο παραπάνω κώδικας δείχνει την αναπαράσταση συμβολοσειράς του, που είναι ο πηγαίος κώδικας.

Σίγουρα, μια συνάρτηση είναι μια ειδική τιμή, με την έννοια ότι μπορούμε να την ονομάσουμε σαν `sayHi()`.

Αλλά εξακολουθεί να είναι μια τιμή. Έτσι μπορούμε να δουλέψουμε με αυτό όπως με άλλα είδη αξιών.

Μπορούμε να αντιγράψουμε μια συνάρτηση σε μια άλλη μεταβλητή:

```js run no-beautify
function sayHi() {
  // (1) δημιουργήστε
  alert("Hello");
}

let func = sayHi; // (2) αντίγραφο

func(); // Hello     // (3) εκτελέστε το αντίγραφο (δουλεύει)!
sayHi(); // Hello    //     αυτό εξακολουθεί να λειτουργεί επίσης (γιατί όχι)
```

Here's what happens above in detail:

1. Η δήλωση συνάρτησης `(1)` δημιουργεί τη συνάρτηση και την τοποθετεί στη μεταβλητή με το όνομα `sayHi`.
2. Η γραμμή `(2)` την αντιγράφει στη μεταβλητή `func`. Σημειώστε ξανά: δεν υπάρχουν παρενθέσεις μετά το «sayHi». Αν υπήρχε, τότε το `func = sayHi()` θα έγραφε _το αποτέλεσμα της κλήσης_ `sayHi()` στο `func`, όχι στην ίδια τη συνάρτηση` `sayHi`.
3. Τώρα η συνάρτηση μπορεί να κληθεί και ως `sayHi()` και ως `func()`.

Θα μπορούσαμε επίσης να χρησιμοποιήσουμε μια έκφραση συνάρτησης για να δηλώσουμε «sayHi», στην πρώτη γραμμή:

```js
let sayHi = function () {
  // (1) δημιουργήστε
  alert("Hello");
};

let func = sayHi;
// ...
```

Όλα θα λειτουργούσαν το ίδιο.

````smart header="Γιατί υπάρχει ερωτηματικό στο τέλος;"
Ίσως αναρωτιέστε γιατί οι εκφράσεις συνάρτησης έχουν ερωτηματικό «;» στο τέλος, αλλά οι Δηλώσεις συναρτήσεων δεν έχουν:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

Η απάντηση είναι απλή: μια Έκφραση Συνάρτησης δημιουργείται εδώ ως `συνάρτηση(…) {…}` μέσα στη δήλωση ανάθεσης: «ας sayHi = …;». Το ερωτηματικό `;` συνιστάται στο τέλος της δήλωσης, δεν αποτελεί μέρος της σύνταξης της συνάρτησης.

Το ερωτηματικό θα ήταν εκεί για μια απλούστερη ανάθεση, όπως `ας sayHi = 5;`, και υπάρχει επίσης για μια ανάθεση συνάρτησης.
````

## Συναρτήσεις επανάκλησης

Ας δούμε περισσότερα παραδείγματα μεταβίβασης συναρτήσεων ως τιμών και χρήσης παραστάσεων συναρτήσεων.

Θα γράψουμε μια συνάρτηση `ask(ερώτηση, ναι, όχι)` με τρεις παραμέτρους:

`Ερώτηση`.
: Κείμενο της ερώτησης

`Yes`.
: Λειτουργία για εκτέλεση εάν η απάντηση είναι `Yes`

`No`.
: Λειτουργία για εκτέλεση εάν η απάντηση είναι `No`

Η συνάρτηση πρέπει να κάνει την «ερώτηση» και, ανάλογα με την απάντηση του χρήστη, να καλεί `yes()` ή `no()`:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// χρήση: οι συναρτήσεις showOk, showCancel μεταβιβάζονται ως ορίσματα προς ερώτηση
ask("Do you agree?", showOk, showCancel);
```

Στην πράξη, τέτοιες λειτουργίες είναι αρκετά χρήσιμες. Η κύρια διαφορά μεταξύ μιας πραγματικής `ερώτησης` και του παραπάνω παραδείγματος είναι ότι οι πραγματικές συναρτήσεις χρησιμοποιούν πιο σύνθετους τρόπους αλληλεπίδρασης με τον χρήστη από μια απλή `επιβεβαίωση`. Στο πρόγραμμα περιήγησης, τέτοιες λειτουργίες συνήθως σχεδιάζουν ένα όμορφο παράθυρο ερωτήσεων. Αλλά αυτό είναι μια άλλη ιστορία.

**Τα ορίσματα `showOk` και `showCancel` του `ask` ονομάζονται _συναρτήσεις επανάκλησης_ ή απλώς _callbacks_.**

Η ιδέα είναι ότι περνάμε μια συνάρτηση και περιμένουμε να "κληθεί πίσω" αργότερα εάν χρειαστεί. Στην περίπτωσή μας, το `showOk` γίνεται η επανάκληση για την απάντηση `ναι` και `showCancel` για την απάντηση `όχι`.

Μπορούμε να χρησιμοποιήσουμε τις εκφράσεις συνάρτησης για να γράψουμε μια ισοδύναμη, μικρότερη συνάρτηση:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
*/!*
```

Εδώ, οι συναρτήσεις δηλώνονται ακριβώς μέσα στην κλήση `ask(...)`. Δεν έχουν όνομα, και έτσι ονομάζονται _ανώνυμοι_. Τέτοιες συναρτήσεις δεν είναι προσπελάσιμες εκτός του «ρωτήστε» (επειδή δεν έχουν εκχωρηθεί σε μεταβλητές), αλλά αυτό ακριβώς θέλουμε εδώ.

Ένας τέτοιος κώδικας εμφανίζεται στα σενάρια μας πολύ φυσικά, είναι στο πνεύμα της JavaScript.

```smart header="Μια συνάρτηση είναι μια τιμή που αντιπροσωπεύει μια "ενέργεια""
Οι κανονικές τιμές όπως οι συμβολοσειρές ή οι αριθμοί αντιπροσωπεύουν τα *δεδομένα*.

Μια συνάρτηση μπορεί να εκληφθεί ως *ενέργεια*.

Μπορούμε να το περάσουμε ανάμεσα σε μεταβλητές και να το τρέξουμε όποτε θέλουμε.
```

## Έκφραση συνάρτησης έναντι δήλωση συνάρτησης

Ας διατυπώσουμε τις βασικές διαφορές μεταξύ Δηλώσεων Συναρτήσεων και Εκφράσεων.

Πρώτον, η σύνταξη: πώς να τα διαφοροποιήσετε στον κώδικα.

- _Δήλωση συνάρτησης:_ μια συνάρτηση, που δηλώνεται ως ξεχωριστή δήλωση, στην κύρια ροή κώδικα:

  ```js
  // Δήλωση συνάρτησης
  function sum(a, b) {
    return a + b;
  }
  ```

- _Έκφραση συνάρτησης:_ μια συνάρτηση, που δημιουργείται μέσα σε μια έκφραση ή μέσα σε μια άλλη δομή σύνταξης. Εδώ, η συνάρτηση δημιουργείται στη δεξιά πλευρά της "έκφρασης ανάθεσης" `=`:

  ```js
  // Έκφραση συνάρτησης
  let sum = function (a, b) {
    return a + b;
  };
  ```

Η πιο λεπτή διαφορά είναι _όταν_ δημιουργείται μια συνάρτηση από τη μηχανή JavaScript.

**Μια έκφραση συνάρτησης δημιουργείται όταν φτάσει η εκτέλεση και μπορεί να χρησιμοποιηθεί μόνο από εκείνη τη στιγμή.**

Μόλις η ροή εκτέλεσης περάσει στη δεξιά πλευρά της εκχώρησης `ας αθροίσουμε = συνάρτηση…` -- εδώ πάμε, η συνάρτηση δημιουργείται και μπορεί να χρησιμοποιηθεί (εκχωρηθεί, κληθεί κ.λπ. ) από εδώ και στο εξής.

Οι δηλώσεις λειτουργιών είναι διαφορετικές.

**Μια δήλωση συνάρτησης μπορεί να κληθεί νωρίτερα από ό,τι έχει οριστεί.**

Για παράδειγμα, μια καθολική δήλωση συνάρτησης είναι ορατή σε ολόκληρο το σενάριο, ανεξάρτητα από το πού βρίσκεται.

Αυτό οφείλεται σε εσωτερικούς αλγόριθμους. Όταν η JavaScript προετοιμάζεται να εκτελέσει το σενάριο, αναζητά πρώτα καθολικές δηλώσεις συναρτήσεων σε αυτό και δημιουργεί τις συναρτήσεις. Μπορούμε να το σκεφτούμε ως «στάδιο αρχικοποίησης».

Και μετά την επεξεργασία όλων των Δηλώσεων Συναρτήσεων, ο κώδικας εκτελείται. Άρα έχει πρόσβαση σε αυτές τις λειτουργίες.

Για παράδειγμα, αυτό λειτουργεί:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Η δήλωση συνάρτησης `sayHi` δημιουργείται όταν η JavaScript ετοιμάζεται να ξεκινήσει το σενάριο και είναι ορατή παντού μέσα σε αυτό.

...Αν ήταν μια έκφραση συνάρτησης, τότε δεν θα λειτουργούσε:

```js run refresh untrusted
*!*
sayHi("John"); // Σφάλμα!
*/!*

let sayHi = function(name) {  // (*) καμία μαγεία πια
  alert( `Hello, ${name}` );
};
```

Οι εκφράσεις συνάρτησης δημιουργούνται όταν φτάσει η εκτέλεση σε αυτές. Αυτό θα συνέβαινε μόνο στη γραμμή «(\*)». Πολύ αργά.

Ένα άλλο ιδιαίτερο χαρακτηριστικό των Δηλώσεων Συναρτήσεων είναι το εύρος μπλοκ τους.

**Στην αυστηρή λειτουργία, όταν μια δήλωση συνάρτησης βρίσκεται μέσα σε ένα μπλοκ κώδικα, είναι ορατή παντού μέσα σε αυτό το μπλοκ. Όχι όμως έξω από αυτό.**

Για παράδειγμα, ας φανταστούμε ότι πρέπει να δηλώσουμε μια συνάρτηση `welcome()` ανάλογα με τη μεταβλητή `age` που λαμβάνουμε κατά τη διάρκεια του χρόνου εκτέλεσης. Και μετά σκοπεύουμε να το χρησιμοποιήσουμε λίγο καιρό αργότερα.

Εάν χρησιμοποιήσουμε τη δήλωση συνάρτησης, δεν θα λειτουργήσει όπως προβλέπεται:

```js run
let age = prompt("What is your age?", 18);

// δηλώνει υπό όρους μια συνάρτηση
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...χρησιμοποιήστε το αργότερα
*!*
welcome(); // Σφάλμα: το καλωσόρισμα δεν έχει οριστεί
*/!*
```

Αυτό συμβαίνει επειδή μια δήλωση συνάρτησης είναι ορατή μόνο μέσα στο μπλοκ κώδικα στο οποίο βρίσκεται.

Εδώ είναι ένα άλλο παράδειγμα:

```js run
let age = 16; // πάρτε ως παράδειγμα το 16

if (age < 18) {
*!*
  welcome();               // \   (τρέχει)
*/!*
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  Η δήλωση λειτουργίας είναι διαθέσιμη
  }                        //  |  παντού στο μπλοκ όπου έχει δηλωθεί
                           //  |
*!*
  welcome();               // /   (τρέχει)
*/!*

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// Εδώ έχουμε τελειώσει τα σγουρά σιδεράκια,
// έτσι δεν μπορούμε να δούμε Δηλώσεις συναρτήσεων που γίνονται μέσα σε αυτές.

*!*
welcome(); // Σφάλμα: το καλωσόρισμα δεν έχει οριστεί
*/!*
```

Τι μπορούμε να κάνουμε για να κάνουμε το `welcome` ορατό έξω από το `if`;

Η σωστή προσέγγιση θα ήταν να χρησιμοποιήσετε μια Έκφραση συνάρτησης και να εκχωρήσετε `welcome` στη μεταβλητή που δηλώνεται εκτός του `if` και έχει την κατάλληλη ορατότητα.

Αυτός ο κώδικας λειτουργεί όπως προβλέπεται:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // εντάξει τώρα
*/!*
```

Ή θα μπορούσαμε να το απλοποιήσουμε ακόμη περισσότερο χρησιμοποιώντας έναν τελεστή ερωτηματικού `?`:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // εντάξει τώρα
*/!*
```

```smart header="Πότε να επιλέξετε Δήλωση συνάρτησης έναντι Έκφρασης συνάρτησης;"
Ως εμπειρικός κανόνας, όταν πρέπει να δηλώσουμε μια συνάρτηση, το πρώτο πράγμα που πρέπει να λάβουμε υπόψη είναι η σύνταξη της δήλωσης συνάρτησης. Δίνει περισσότερη ελευθερία στον τρόπο οργάνωσης του κώδικά μας, επειδή μπορούμε να καλέσουμε τέτοιες συναρτήσεις πριν δηλωθούν.

Αυτό είναι επίσης καλύτερο για την αναγνωσιμότητα, καθώς είναι πιο εύκολο να αναζητήσετε τη «συνάρτηση f(…) {…}» στον κώδικα από το «έστω f = συνάρτηση(…) {…};». Οι δηλώσεις συναρτήσεων είναι πιο «τραβηγμένες».

...Αλλά εάν μια δήλωση συνάρτησης δεν μας ταιριάζει για κάποιο λόγο ή χρειαζόμαστε μια δήλωση υπό όρους (είχαμε μόλις ένα παράδειγμα), τότε θα πρέπει να χρησιμοποιηθεί η έκφραση συνάρτησης.
```

## Περίληψη

- Οι συναρτήσεις είναι αξίες. Μπορούν να αντιστοιχιστούν, να αντιγραφούν ή να δηλωθούν σε οποιοδήποτε σημείο του κωδικού.
- Εάν η συνάρτηση δηλωθεί ως ξεχωριστή δήλωση στην κύρια ροή κώδικα, αυτό ονομάζεται "Δήλωση συνάρτησης".
- Εάν η συνάρτηση δημιουργείται ως μέρος μιας έκφρασης, ονομάζεται "Έκφραση συνάρτησης".
- Οι δηλώσεις συναρτήσεων υποβάλλονται σε επεξεργασία πριν από την εκτέλεση του μπλοκ κώδικα. Είναι ορατά παντού στο μπλοκ.
- Οι εκφράσεις συνάρτησης δημιουργούνται όταν φτάσει σε αυτές η ροή εκτέλεσης.

Στις περισσότερες περιπτώσεις, όταν χρειάζεται να δηλώσουμε μια συνάρτηση, είναι προτιμότερη μια δήλωση συνάρτησης, επειδή είναι ορατή πριν από την ίδια τη δήλωση. Αυτό μας δίνει μεγαλύτερη ευελιξία στην οργάνωση κώδικα και είναι συνήθως πιο ευανάγνωστο.

Επομένως, θα πρέπει να χρησιμοποιούμε μια έκφραση συνάρτησης μόνο όταν μια δήλωση συνάρτησης δεν είναι κατάλληλη για την εργασία. Έχουμε δει μερικά παραδείγματα αυτού σε αυτό το κεφάλαιο και θα δούμε περισσότερα στο μέλλον.
