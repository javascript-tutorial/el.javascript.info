# Συναρτήσεις

Πολύ συχνά πρέπει να κάνουμε παρόμοια εργασιες σε πολλά σημεία του script.

Για παράδειγμα, πρέπει να δείξουμε ένα ωραίο μήνυμα όταν ένας επισκέπτης συνδέεται ή αποσυνδέεται σε κάποιο σημείο της εφαρμογής.

Οι συναρτήσεις είναι τα κύρια "building blocks" του προγράμματος. Επιτρέπουν στον κωδικό να καλείται πολλές φορές χωρίς επανάληψη.

Έχουμε ήδη δει παραδείγματα ενσωματωμένων συναρτήσεων, όπως `alert(message)`, `prompt(message, default)` καί `confirm(question)`. Μπορούμε όμως να δημιουργήσουμε και δικές μας συναρτήσεις.

## Function Declaration

Για να δημιουργήσουμε μια συνάρτηση μπορούμε να χρησιμοποιήσουμε το *function declaration*.

Υλοποιείται με αυτό το τρόπο:

```js
function showMessage() {
  alert( 'Hello everyone!' );
}
```

Η λέξη-κλειδί `function` πηγαίνει πρώτα, μετά πηγαίνει το `όνομα της συνάρτησης`, μετά μια λίστα *παραμέτρων* μεταξύ των παρενθέσεων (διαχωρισμένη με κόμμα, κενή στο παραπάνω παράδειγμα) και τέλος ο κωδικός της συνάρτησης, που ονομάζεται επίσης "the function body", ανάμεσα σε άγκιστρα.

```js
function name(parameter1, parameter2, ... parameterN) {
 // body
}
```

Η νέα μας συνάρτηση μπορεί να κληθεί με το όνομά της: `showMessage()`.

Για παράδειγμα:

```js run
function showMessage() {
  alert( 'Hello everyone!' );
}

*!*
showMessage();
showMessage();
*/!*
```

Η κλήση `showMessage()` εκτελεί τον κωδικό της συνάρτησης. Εδώ θα δούμε το μήνυμα δύο φορές.

Αυτό το παράδειγμα καταδεικνύει με σαφήνεια έναν από τους κύριους σκοπούς των συναρτήσεων: την αποφυγή αντιγραφής του κώδικα.

Εάν κάποτε χρειαστεί να αλλάξουμε το μήνυμα ή τον τρόπο που εμφανίζεται, αρκεί να τροποποιήσουμε τον κώδικα σε ένα μέρος: τη συνάρτηση που το εξάγει.


## Τοπικές μεταβλητές

Μια μεταβλητή που δηλώνεται μέσα σε μια συνάρτηση είναι ορατή μόνο μέσα σε αυτήν.

Για παράδειγμα:

```js run
function showMessage() {
*!*
  let message = "Hello, I'm JavaScript!"; // τοπική μεταβλητή
*/!*

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! Η μεταβλητή ειναι τοπική
```

## Εξωτερικές μεταβλητές

Μια συνάρτηση μπορεί να έχει πρόσβαση και σε μια εξωτερική μεταβλητή, για παράδειγμα:

```js run no-beautify
let userName = 'John';

function showMessage() {
  let message = 'Hello, ' + userName;
  alert(message);
}

showMessage(); // Hello, John
```

Η συνάρτηση έχει πλήρη πρόσβαση στην εξωτερική μεταβλητή. Μπορεί επίσης να την τροποποιήσει.

Για παράδειγμα:

```js run
let *!*userName*/!* = 'John';

function showMessage() {
  *!*userName*/!* = "Bob"; // (1) τροποποιήσει της εξωτερικής μεταβλητής

  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* πριν την εκτέλεση της συνάρτηση

showMessage();

alert( userName ); // *!*Bob*/!*, η τιμή εχει τροποποιήθει απο την συνάρτηση
```

Η εξωτερική μεταβλητή χρησιμοποιείται μόνο εφόσον δεν υπάρχει τοπική.

Εάν μια ίδια μεταβλητή δηλώνεται μέσα στη function, τότε *σκιάζει* την εξωτερική. Για παράδειγμα, στον παρακάτω κώδικα η συνάρτηση χρησιμοποιεί την local `userName`. Το εξωτερικό αγνοείται:

```js run
let userName = 'John';

function showMessage() {
*!*
  let userName = "Bob"; // δήλωση τοπικής μεταβλητής
*/!*

  let message = 'Hello, ' + userName; // *!*Bob*/!*
  alert(message);
}

// η συνάρτηση θα δημιουργήσει και θα χρησιμοποιήσει δικό της όνομα χρήστη
showMessage();

alert( userName ); // *!*John*/!*, αμετάβλητη, η συνάρτηση δεν είχε πρόσβαση στην εξωτερική μεταβλητή
```

```smart header="Global variables"
Οι μεταβλητές που δηλώνονται εκτός συνάρτησης, όπως το εξωτερικό `userName` στον παραπάνω κωδικό, ονομάζονται *global*.

Οι global μεταβλητές είναι ορατές από οποιαδήποτε συνάρτηση (εκτός εάν επισκιάζονται από locals).

Είναι καλή πρακτική να ελαχιστοποιήσετε τη χρήση global μεταβλητών. Ο σύγχρονος κώδικας έχει λίγα ή καθόλου global. Οι περισσότερες μεταβλητές βρίσκονται στις συναρτήσεις τους. Μερικές φορές όμως, μπορούν να είναι χρήσιμα για την αποθήκευση δεδομένων σε project-level.
```

## Παράμετροι

Μπορούμε να μεταφέρουμε αυθαίρετα δεδομένα σε συναρτήσεις χρησιμοποιώντας παραμέτρους (επίσης λέγεται *συνάρτηση arguments*) .

Στο παρακάτω παράδειγμα, η συνάρτηση έχει δύο παραμέτρους: `from` και `text`.

```js run
function showMessage(*!*from, text*/!*) { // parameters: from, text
  alert(from + ': ' + text);
}

*!*showMessage('Ann', 'Hello!');*/!* // Ann: Hello! (*)
*!*showMessage('Ann', "What's up?");*/!* // Ann: What's up? (**)
```

Όταν η συνάρτηση καλείται στις γραμμές `(*)` και `(**)`, οι δεδομένες τιμές αντιγράφονται στις τοπικές μεταβλητές `from` και `text`. Στη συνέχεια, η συνάρτηση τα χρησιμοποιεί.

Ακολουθεί ένα ακόμη παράδειγμα: έχουμε μια μεταβλητή `from` και τη μεταδίδουμε στη συνάρτηση. Παρακαλώ σημειώστε: η συνάρτηση αλλάζει `from`, αλλά η αλλαγή δεν φαίνεται έξω, επειδή μια συνάρτηση παίρνει πάντα ένα αντίγραφο της τιμής:

*!*
  from = '*' + from + '*'; // make "from" look nicer
*/!*

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// η τιμή του `from` είναι η ίδια, η συνάρτηση τροποποίησε μια τοπικη αντίγραφη
alert( from ); // Ann
```

## Προκαθορισμένες τιμές

Εάν μια παράμετρος δεν παρέχεται, τότε η τιμή της γίνεται `undefined`.

Για παράδειγμα, η προαναφερθείσα συνάρτηση `showMessage(from, text)` μπορεί να κληθεί με ένα μόνο όρισμα:

```js
showMessage("Ann");
```
Αυτό δεν είναι λάθος. Μια τέτοια κλήση θα έδινε το `"Ann: undefined"`. Δεν υπάρχει `text`, έτσι θεωρούμαι ότι το `text === undefined`.

Αν θέλουμε να χρησιμοποιήσουμε ένα "default" `text` σε αυτήν την περίπτωση, τότε μπορούμε να το καθορίσουμε μετά το `=`:

```js run
function showMessage(from, *!*text = "no text given"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: δεν έχει δοθεί κείμενο
```

Τώρα, εάν η παράμετρος `text` δεν δοθεί, θα λάβει την τιμή `"no text given"`.

```js
showMessage("Ann", undefined); // Ann: no text given
```

Εδώ `"no text given"` είναι μια συμβολοσειρά, αλλά μπορεί να είναι μια πιο περίπλοκη έκφραση, η οποία αξιολογείται και αναθέτετε μόνο εάν λείπει η παράμετρος. Αυτό είναι επίσης δυνατό:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() εκτελείται μόνο εάν δεν δίνεται `text`
  // το αποτέλεσμα ειναι η τιμή του `text`
}
```

```smart header="Evaluation of default parameters"
Στην JavaScript, μια προεπιλεγμένη παράμετρος αξιολογείται κάθε φορά που καλείται η συνάρτηση χωρίς την αντίστοιχη παράμετρο.

Στο παραπάνω παράδειγμα, το `anotherFunction()` καλείται κάθε φορά που το `showMessage()` καλείται χωρίς την παράμετρο `text`.

### Εναλλακτικοί προεπιλεγμένοι παράμετροι

Μερικές φορές έχει νόημα να ορίσετε προεπιλεγμένες τιμές για παραμέτρους όχι στη δήλωση συνάρτησης, αλλά σε μεταγενέστερο στάδιο, κατά την εκτέλεση.

<<<<<<< HEAD
Για να ελέγξουμε μια παράμετρο που παραλείφθηκε, μπορούμε να τη συγκρίνουμε με το `undefined`:
=======
For example, an explicit check for `undefined`:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'no text given';
  }
*/!*

  alert( from + ": " + text );
}
```

...Or using the `||` operator:

```js
function showMessage(from, text) {
  // If the value of text is falsy, assign the default value
  // this assumes that text == "" is the same as no text at all
  text = text || 'no text given';
  ...
}
```
````


### Alternative default parameters

Sometimes it makes sense to assign default values for parameters at a later stage after the function declaration.

We can check if the parameter is passed during the function execution, by comparing it with `undefined`:
>>>>>>> bf7d8bb1af3b416d393af1c15b03cb1352da1f9c

```js run
function showMessage(text) {
  // ...

*!*
  if (text === "undefined") {
    text = 'empty message';
  }
*/!*

  alert(text);
}

showMessage(); // empty message
```

...Ή θα μπορούσαμε να χρησιμοποιήσουμε τον τελεστή `||`:

```js
// εάν η παράμετρος παραλειφθεί ή "" περάσει, τότε θα ορίστε σε 'empty'

  ...
}
```

Οι σύγχρονες μηχανές JavaScript υποστηρίζουν το [nullish coalescing operator](info:nullish-coalescing-operator) `??`, είναι όμως καλύτερα οι ψευδείς τιμές όπως το `0` να θεωρούνται κανονικές:


```js run
function showCount(count) {
  // if count is undefined or null, show "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

## Επιστροφή τιμής

Μια συνάρτηση μπορεί να επιστρέψει μια τιμή στον καλούμενο κώδικα ως αποτέλεσμα.

Το απλούστερο παράδειγμα θα ήταν μια συνάρτηση που προσθέτει δύο τιμές:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

Η οδηγία `result` μπορεί να βρίσκεται σε οποιοδήποτε σημείο της συνάρτησης. Όταν φτάσει η εκτέλεση, η συνάρτηση σταματά και η τιμή επιστρέφεται στον καλούμενο κώδικα (αντιστοιχεί στο παραπάνω `result`).

Η `return` μπορεί να εμφανιστεί πολλες φορές σε μία μόνο συνάρτηση. Για παράδειγμα:

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('Do you have permission from your parents?');
*/!*
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
```

Υπάρχει περίπτωση να χρησιμοποιήσετε την `return` χωρίς τιμή. Αυτό αναγκάζει τη λειτουργία να κλείσει αμέσως.

Για παράδειγμα:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
```

Στον παραπάνω κάδικα, εάν το `checkAge(age)` επιστρέφει `false`, τότε το `showMovie` δεν θα προχωρήσει στην `alert`.

````smart header="Μια συνάρτηση με ένα κενό ή χωρίς `return` θα επιστρέφει `undefined`"
Εάν μια συνάρτηση δεν επιστρέφει καμία τιμή, τοτε θα επιστρέφει `undefined`:

```js run
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
```

Ένα κενό `return` είναι επίσης το ίδιο με το `return undefined`:

```js run
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```
````

````warn header="Ποτέ μην αλλάζετε μια γραμμή μεταξύ `return` και της τιμής"
Μια έκφραση στο `return`, μπορεί να φαίνεται δελεαστικό να την τοποθετήσετε σε μια ξεχωριστή γραμμή, κάπως έτσι:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
Όμως δεν λειτουργεί με αυτό τρόπο, επειδή η JavaScript παίρνει ένα ερωτηματικό μετά το `return`. Αυτό θα λειτουργήσει το ίδιο όπως:

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

Το αποτέλεσμα είναι μια κενή επιστροφή.

Εάν θέλουμε την επιστρώφει της επιστρεφόμενης έκφρασης σε πολλές γραμμές, θα πρέπει να την τοποθετήσουμε στην ίδια γραμμή με το `return`. Ή τουλάχιστον βάλτες στις παρενθέσεις, ως εξής:

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
Και θα λειτουργήσει όπως το περιμένουμε.
````

## Το όνομα μιας συνάρτησης [#function-naming]

Οι συναρτήσεις είναι ενέργειες. Έτσι το όνομά τους είναι συνήθως ένα ρήμα. Θα πρέπει να είναι σύντομη, όσο το δυνατόν ακριβέστερη και να περιγράφει τι κάνει η λειτουργία, έτσι ώστε κάποιος που διαβάζει τον κωδικό να λάβει μια ένδειξη για το τι κάνει η λειτουργία.

Είναι μια διαδεδομένη πρακτική να ξεκινήσετε μια συνάρτηση με ένα λεκτικό πρόθεμα που περιγράφει αόριστα τη δράση. Πρέπει να υπάρχει συμφωνία εντός της ομάδας για την έννοια των προθημάτων.

Για παράδειγμα, οι συναρτήσεις που ξεκινούν με το `"show"` συνήθως δείχνουν κάτι.

Οι συναρτήσεις ξεκινάνε κάπως έτσι...

- `"get…"` -- επιστρέψει μια τιμή,
- `"calc…"` -- υπολογιζει κάτι,
- `"create…"` -- δημιουργεί κάτι,
- `"check…"` -- ελέγχει κάτι και επιστρέφει ένα boolean, κ.τ.λ.

Παραδείγματα τέτοιων ονομασιών:

```js no-beautify
showMessage(..)     // δείχνει ένα μύνημα
getAge(..)          // επιστρέφει την ηλικία (τα παίρνει από κάπου)
calcSum(..)         // υπολογίζει ένα άθροισμα και επιστρέφει το αποτέλεσμα
createForm(..)      // δημιουργεί μια φόρμα (κυρίως την επιστρέφει)
checkPermission(..) // ελέγχει μια 	συναίνεση, επιστρέφει true/false
```

Με τα προθέματα στη θέση τους, μια ματιά σε ένα όνομα συνάρτησης δίνει μια κατανόηση τι είδους δουλειά κάνει και τι είδους τιμή επιστρέφει.

```smart header="Μια συνάρτηση -- μια δράση"
Μια συνάρτηση πρέπει να κάνει ακριβώς αυτό που δηλώνει το όνομά της, όχι κάτι πλέον.

Δύο ανεξάρτητες ενέργειες συνήθως ειναι δύο συναρτήσεις, ακόμα κι αν συνήθως κληθούν μαζί (σε αυτήν την περίπτωση μπορούμε να δημιουργήσουμε μια 3η συνάρτηση που καλεί αυτές τις δύο).

Μερικά παραδείγματα παραβίασης αυτού του κανόνα:

- `getAge` -- θα ήταν κακό αν εμφανίζει `alert` με την ηλικία (πρέπει μόνο να δέχεται).
- `createForm` -- θα ήταν άσχημο αν τροποποιήθει το έγγραφο, προσθέτοντας μια φόρμα σε αυτό (θα πρέπει μόνο να δημιουργήθεί και να επιστραφεί).
- `checkPermission` -- θα ήταν άσχημο εαν εμφανιζόταν το μήνυμα `access granted/denied` (θα πρέπει μόνο να έλεγχει την εκτέλεση και να επιστρέφει το αποτέλεσμα).

Αυτά τα παραδείγματα θεωρούνται κοινές έννοιες των prefixes. Εσείς και η ομάδα σας είστε ελεύθεροι να συμφωνήσετε για άλλες έννοιες, αλλά συνήθως δεν διαφέρουν πολύ. Σε κάθε περίπτωση, θα πρέπει να έχετε μια σταθερή κατανόηση το τι σημαίνει ένα prefix, τι μπορεί και τι δεν μπορεί να κάνει μια προκαταρκτική συνάρτηση. Όλες οι συναρτήσεις του ίδιου prefix πρέπει να τηρούν τους κανόνες. Και η ομάδα πρέπει να μοιραστεί τις γνώσεις.
```

```smart header="'Ονομα συνάρτησης Ultrashort"
Οι συναρτήσεις που χρησιμοποιούνται *πολύ συχνά* μερικές φορές έχουν συντομα ονόματα.

Για παράδειγμα το [jQuery](http://jquery.com) βιβλιοθήκη ορίζει μια συνάρτηση με `$`. Το [Lodash](http://lodash.com/) βιβλιοθήκη δηλώνει τις συναρτήσεις με `_`.

Αυτές είναι εξαιρέσεις. Γενικά τα ονόματα των συναρτήσεων πρέπει να είναι συνοπτικά και περιγραφικά.

```
## Συναρτήσεις == Σχόλια

Οι συναρτήσεις πρέπει να είναι σύντομες και να κάνουν μια συγκεκριμένη λειτουργία. Εάν αυτό τη η λειτουργία είναι μεγάλη, ίσως αξίζει νσ την χωρίσετε τη συνάρτηση σε μερικές μικρότερες συνάρτησης. Μερικές φορές η τήρηση αυτού του κανόνα μπορεί να μην είναι τόσο εύκολη, αλλά σίγουρα είναι η καλύτερη λυση.

Μια ξεχωριστή συνάρτηση δεν είναι μόνο πιο εύκολη στη δοκιμή και τον εντοπισμό σφαλμάτων - η ίδια η ύπαρξή της ειναι η διευκόλυνση σας!

Για παράδειγμα, συγκρίνετε τις δύο συναρτήσεις `showPrimes(n)`. Κάθε ένα εξέρχει [πρώτους αριθμούς](https://en.wikipedia.org/wiki/Prime_number) έως `n`.

Η πρώτη παραλλαγή χρησιμοποιεί μια ετικέτα:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // πρώτος αριθμός
  }
}
```
Η δεύτερη παραλλαγή χρησιμοποιεί μια πρόσθετη συνάρτηση `isPrime (n)` για να δοκιμάσει την αρχικότητα:

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // πρώτος αριθμός
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

Η δεύτερη παραλλαγή είναι πιο κατανοητή, έτσι δεν είναι; Αντί για το κομμάτι κώδικα βλέπουμε ένα όνομα της δράσης (`isPrime`). Μερικές φορές οι άνθρωποι αναφέρονται στον κώδικα ως *self-describing*.

Έτσι, οι συναρτήσεις μπορούν να δημιουργηθούν ακόμη και αν δεν σκοπεύουμε να τις επαναχρησιμοποιήσουμε. Δομούν τον κώδικα και τον κάνουν αναγνώσιμο.

## Περίληψη

Μία function declaration δηλώνεται με αυτό τον τρόπο:

```js
function name(parameters, delimited, by, comma) {
  /* code */
}
```
- Οι τιμές μεταβιβάζονται σε μια συνάρτηση ως παράμετροι, αντιγράφονται στις τοπικές μεταβλητές της.
- Μια συνάρτηση μπορεί να έχει πρόσβαση σε εξωτερικές μεταβλητές. Αλλά λειτουργεί μόνο από μέσα προς τα έξω. Οι τοπικές μεταβλητές ειναι ορατές μόνο μέσα στην συνάρτηση.
- Μια συνάρτηση μπορεί να επιστρέψει μια τιμή. Εάν δεν το κάνει, τότε το αποτέλεσμα είναι `undefined`.

Για να κάνετε τον κώδικα καθαρό και κατανοητό, συνίσταται η χρήση κυρίως τοπικών μεταβλητών και παραμέτρων στη συνάρτηση, όχι εξωτερικών μεταβλητών.

Είναι πάντα πιο εύκολο να κατανοήσουμε μια συνάρτηση που παίρνει παραμέτρους, δουλεύει μαζί τους και επιστρέφει ένα αποτέλεσμα, παρά μια συνάρτηση που δεν έχει παραμέτρους, αλλά τροποποιεί τις εξωτερικές μεταβλητές ως side-effect.

Ονομασία συναρτήσεων:

- Ένα όνομα πρέπει να περιγράφει με σαφήνεια την λειτουργία της συνάρτησης. Ένα καλό όνομα μας δίνει αμέσως τι κάνει και τι επιστρέφει μια συνάρτηση.
- Μια συνάρτηση είναι μια δράση, επομένως τα ονόματα των συνάρτησης είναι συνήθως λεκτικά.
- Υπάρχουν πολλά γνωστά προθέματα συναρτήσεων όπως `create…`, `show…`, `get…`, `check…` και ούτω καθεξής. Χρησιμοποιήστε τα για να υποδείξετε τι κάνει μια συνάρτηση.

Οι συναρτήσεις είναι τα κύρια δομικά στοιχεία των scripts. Τώρα έχουμε καλύψει τα βασικά, έτσι μπορούμε πραγματικά να αρχίσουμε να τα δημιουργούμε και να τα χρησιμοποιούμε. Αλλά αυτή είναι μόνο η αρχή του μονοπατιού. Θα επιστρέψουμε σε αυτές πολλές φορές, πηγαίνοντας βαθύτερα στα προηγμένα χαρακτηριστικά τους.
