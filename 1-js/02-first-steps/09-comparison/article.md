# Συγκρίσεις

Γνωρίζουμε αρκετούς τελεστές σύγκρισης από μαθηματικά:

Στην JavaScript, είναι γραμμένα με αυτό τον τρόπο:


- Μεγαλύτερο/μικρότερο από: <code>a &gt; b</code>, <code>a &lt; b</code>.
- Μεγαλύτερο/μικρότερο από ή ίσον: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- Ισούται: `a == b` (παρακαλώ σημειώστε το σύμβολο του διπλού ίσον `=`. Το μόνο σύμβολο `a = b`  σήμαινε μια ανάθεση).
- Όχι ισον. Στα μαθηματικά, ο συμβολισμός είναι <code>&ne;</code>, αλλά στην JavaScript γράφεται ως ανάθεση με ένα θαυμαστικό πριν από αυτό: <code>a != b</code>.

Σε αυτό το άρθρο, θα μάθουμε περισσότερα σχετικά με διαφορετικούς τύπους συγκρίσεων, πώς τις δημιουργεί η JavaScript, συμπεριλαμβανομένων σημαντικών ιδιαιτεροτήτων.


## Το αποτέλεσμα είναι Boolean


Όπως όλοι οι υπόλοιποι τελεστές, μια σύγκριση επιστρέφει μια τιμή. Σε αυτήν την περίπτωση, η τιμή είναι δυαδική.

Όλοι οι τελεστές σύγκρισης επιστρέφουν μια δυαδική τιμή:

- `true` -- σημαίνει "yes", "correct" ή "the truth".
- `false` -- σημαίνει "no", "wrong" ή "not the truth".

Ένα παράδειγμα:

```js run
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
```

Ένα αποτέλεσμα σύγκρισης μπορούμε να την αναθέσουμε σε μια μεταβλητή, όπως και κάθε τιμή:

```js run
let result = 5 > 4; // αποτέλεσμα μιας ανάθεσης μίας σύγκριση
alert( result ); // true
```

## Σύγκριση συμβολοσειρών

Για να δείτε εάν μια συμβολοσειρά είναι μεγαλύτερη από μια άλλη, η JavaScript χρησιμοποιεί το λεγόμενο "λεξικό" ή "λεξικογραφική" σειρά.

Με άλλα λόγια, οι συμβολοσειρές συγκρίνονται γράμμα-ανα-γράμμα.

Για παράδειγμα:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

Ο αλγόριθμος που συγκρίνει δύο συμβολοσειρές είναι απλός:

1. Συγκρίνει τον πρώτο χαρακτήρα και των δύο συμβολοσειρών.
2. Εάν ο πρώτος χαρακτήρας από την πρώτη συμβολοσειρά είναι μεγαλύτερος (ή μικρότερος) από τους άλλους συμβολοσειρές, τότε η πρώτη συμβολοσειρά είναι μεγαλύτερη (ή μικρότερη) από τη δεύτερη. Τελειώσαμε.
3. Διαφορετικά, εάν οι πρώτοι χαρακτήρες και των δύο χορδών είναι οι ίδιοι, συγκρίνει τους δεύτερους χαρακτήρες με τον ίδιο τρόπο.
4. Επαναλάμβανει μέχρι το τέλος κάθε συμβολοσειράς.
5. Εάν και οι δύο χορδές έχουν ίδιο μήκος, τότε είναι ίσες. Διαφορετικά, η  συμβολοσειρά με το μεγαλύτερο μήκος είναι μεγαλύτερη.

Στα παραπάνω παραδείγματα, η σύγκριση `"Z" > "A"` φτάνει στο αποτέλεσμα από πρώτο βήμα, ενώ οι συμβολοσειρές `"Glow"` και `"Glee"` συγκρίνονται χαρακτήρες ανά χαρακτήρα:

1. `G` είναι το ίδιο με `G`.
2. `l` είναι το ίδιο με `l`.
3. `o` είναι μεγαλύτερο από `e`. Σταματάει εδώ. Η πρώτη συμβολοσειρά είναι μεγαλύτερη.

```smart header="Not a real dictionary, but Unicode order"
Ο αλγόριθμος σύγκρισης που δίνεται παραπάνω είναι περίπου ισοδύναμος με αυτόν που χρησιμοποιείται σε λεξικά ή τηλεφωνικά βιβλία, αλλά δεν είναι ακριβώς ο ίδιος.

Για παράδειγμα, η υπόθεση έχει σημασία. Το κεφαλαίο γράμμα `"A"` δεν είναι ίσο με το πεζά `"a"`. Ποιο είναι μεγαλύτερο; Τα πεζά `"a"`. Γιατί; Επειδή ο πεζός χαρακτήρας έχει μεγαλύτερο ευρετήριο στον πίνακα εσωτερικής κωδικοποίησης που χρησιμοποιεί JavaScript (Unicode). Θα επιστρέψουμε σε συγκεκριμένες λεπτομέρειες και συνέπειες αυτού στο κεφάλαιο <info:string>.
```

## Σύγκριση διαφορετικών τύπων

Κατά τη σύγκριση των τιμών διαφορετικών τύπων, η JavaScript μετατρέπει τις τιμές σε αριθμούς.

Για παράδειγμα:

```js run
alert( '2' > 1 ); // true, η συμβολοσειρά '2' μετατρέπεται σε αριθμό 2
alert( '01' == 1 ); // true, η συμβολοσειρά '01' μετατρέπεται σε αριθμό 1
```

Για δυαδικές τιμές, το `true` γίνεται `1` και το `false` γίνεται `0`.

Για παράδειγμα:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="A funny consequence"
Είναι πιθανό ότι ταυτόχρονα:

- Δύο τιμές να είναι ίσες.
- Το ένα από αυτά είναι `true` ως boolean και το άλλο `false` ως boolean.

Για παράδειγμα:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

Από την πλευρά της JavaScript, αυτό το αποτέλεσμα είναι αρκετά φυσιολογικό. Ο έλεγχος ισότητας μετατρέπει τιμές χρησιμοποιώντας την αριθμητική μετατροπή (εξ ου και το `"0"` γίνεται `"0"`), ενώ η ρητή μετατροπή "Boolean" χρησιμοποιεί ένα άλλο σύνολο κανόνων.
````

## Αυστηρή ισότητα

Ένας κανονικός έλεγχος ισότητας `==` έχει πρόβλημα. Δεν μπορεί να διαφοροποιήσει το `0` από το `false`:

```js run
alert( 0 == false ); // true
```

Το ίδιο συμβαίνει με μια κενή συμβολοσειρά:

```js run
alert( '' == false ); // true
```

Αυτό συμβαίνει επειδή οι τελεστές διαφορετικών τύπων μετατρέπονται σε αριθμούς από τον τελεστή ισότητας `==`. Μια κενή συμβολοσειρά, όπως το `false`, γίνεται μηδέν.

Τι να κάνουμε εάν θέλουμε να κάνουμε διαφοροποίηση `0` από `false`?

**Ένας αυστηρός τελεστής ισότητας `===` ελέγχει την ισότητα χωρίς μετατροπή τύπου.**

Με άλλα λόγια, εάν τα `a` και `b` είναι διαφορετικού τύπου, τότε το `a === b` επιστρέφει αμέσως `false` χωρίς καμία προσπάθεια μετατροπής τους.

Ας το προσπαθήσουμε:

```js run
alert( 0 === false ); // false, επειδή οι τύποι είναι διαφορετικοί
```

Υπάρχει επίσης ένας "αυστηρός μη ισότητας" τελεστής `!==` ανάλογος με το `!=`.

Ο αυστηρός χειριστής ισότητας είναι λίγο μεγάλο για γράφει, αλλά καθιστά προφανές τι συμβαίνει και αφήνει λιγότερο χώρο για λάθη.

## Σύγκριση με null και undefined

Υπάρχει μια μη διαισθητική συμπεριφορά όταν το `null` ή το `undefined` συγκρίνονται με άλλες τιμές.

Για αυστηρό έλεγχο ισότητας `===`
: Αυτές οι τιμές είναι διαφορετικές επειδή καθεμία από αυτές είναι διαφορετικού τύπου.

    ```js run
    alert( null === undefined ); // false
    ```

Για μη αυστηρό έλεγχο ισότητας `==`
: Υπάρχει ένας ειδικός κανόνας. Αυτά τα δύο είναι ένα "γλυκό ζευγάρι": είναι ίσα μεταξύ τους (με την έννοια `==`), αλλά όχι με άλλη τιμή.

    ```js run
    alert( null == undefined ); // true
    ```

Για μαθηματικά και άλλες συγκρίσεις `< > <= >=`:
Το `null/undefined` μετατρέπονται σε αριθμούς: το `null` γίνεται "0", ενώ το `undefined` γίνεται `NaN`.

Τώρα ας δούμε μερικά αστεία πράγματα που συμβαίνουν όταν εφαρμόζουμε αυτούς τους κανόνες. Και, το πιο σημαντικό, πώς να μην πέσετε σε παγίδα μαζί τους.

### Ασυνήθιστο αποτέλεσμα: null vs 0

Ας συγκρινούμε το `null` με το zero:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

Για τα μαθηματικά, αυτό είναι ασυνήθιστο. Το τελευταίο αποτέλεσμα αναφέρει ότι το "`null` είναι μεγαλύτερο ή ίσο με το μηδέν", οπότε σε μία από τις παραπάνω συγκρίσεις πρέπει να είναι `true`, αλλά και οι δύο είναι ψευδείς.

Ο λόγος είναι ότι ένας έλεγχος ισότητας `==` και οι συγκρίσεις `> <> = <=` λειτουργούν διαφορετικά. Οι συγκρίσεις μετατρέπουν το `null` σε έναν αριθμό, αντιμετωπίζοντας το ως `0`. Γι 'αυτό το (3) `null >= 0` είναι αληθές και (1) `null > 0` είναι ψευδής.

Από την άλλη πλευρά, ο έλεγχος ισότητας `==` για `undefined` και `null` ορίζονται έτσι ώστε χωρίς καμία μετατροπή, να ισούται μεταξύ τους και να μην ισούται με τίποτα άλλο. Γι 'αυτό το (2) το `null == 0` είναι ψευδης.

### Ένα ασύγκριτο undefined

Η τιμή `undefined` δεν πρέπει να συγκρίνεται με άλλες τιμές:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

Γιατί δεν του αρέσει πολύ το μηδέν; Πάντα ψευδής!

Ο λόγος που λαμβάνουμε αυτά τα αποτελέσματα είναι:

- Οι συγκρίσεις `(1)` και `(2)` επιστρέφουν `false` επειδή το `undefined` μετατρέπεται σε `NaN` και το `NaN` είναι μια ειδική αριθμητική τιμή που επιστρέφει `false` για όλες τις συγκρίσεις.

- Ο έλεγχος ισότητας `(3)` επιστρέφει `false` επειδή `undefined` ισούται μόνο με `null`, `undefined` και καμία άλλη τιμή.

### Αποφύγετε τα προβλήματα

Γιατί εξετάσαμε αυτά τα παραδείγματα; Πρέπει να θυμόμαστε αυτές τις ιδιαιτερότητες όλη την ώρα; Βασικά, όχι ακριβώς. Στην πραγματικότητα, αυτά τα δύσκολα πράγματα θα εξοικειωθούν σταδιακά με την πάροδο του χρόνου, αλλά υπάρχει ένας σταθερός τρόπος για να αποφύγετε τα προβλήματα μαζί τους:

Απλώς αντιμετωπίστε οποιαδήποτε σύγκριση με το `undefined/null` εκτός από την αυστηρή ισότητα `===` με εξαιρετική προσοχή.

Μην χρησιμοποιείτε συγκρίσεις `> => < <=` με μια μεταβλητή που μπορεί να είναι `null/undefined`, εκτός εάν είστε πραγματικά σίγουροι για το τι κάνετε. Εάν μια μεταβλητή μπορεί να έχει αυτές τις τιμές, ελέγξτε τις ξεχωριστά.

## Περίληψη

- Οι τελεστές σύγκρισης επιστρέφουν μια δυαδική τιμή.
- Οι συμβολοσειρές συγκρίνονται γράμματα με γράμμα με τη σειρά `λεξικό`.
- Όταν συγκρίνονται τιμές διαφορετικών τύπων, μετατρέπονται σε αριθμούς (με εξαίρεση έναν αυστηρό έλεγχο ισότητας).
- Οι τιμές `null` και `undefined` είναι ίσες `==` μεταξύ τους και δεν ισούται με καμία άλλη τιμή.
- Να είστε προσεκτικοί όταν χρησιμοποιείτε συγκρίσεις όπως `>` ή `<` με μεταβλητές που μπορεί περιστασιακά να είναι `null/undefined`. Ο ξεχωριστός έλεγχος για το `null/undefined` είναι καλή ιδέα.
